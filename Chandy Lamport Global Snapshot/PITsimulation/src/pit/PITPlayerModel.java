package pit;

import java.io.Serializable;
import java.util.*;
import javax.jms.*;
import javax.jms.Queue;
import javax.naming.*;

/*
 * This is the ONLY file that you are to edit.  It is the model of play for
 * every PITplayer.  Each PITplayer instantiates this model and uses it to
 * process the messages it receives.
 */
public class PITPlayerModel {

    // Each PITplayer has a unique myPlayerNumber.  It is set in the PITPlayer constructor.
    private final int myPlayerNumber;
    // Cards is this player's set of cards.
    private final ArrayList cards = new ArrayList();
    // numTrades counts trades.
    private int numTrades = 0;
    // maxTrades is the maximum number of trades, after which trading is stopped.
    private final int maxTrades = 20000;
    // numPlayers are the number of Players trading.  This comes with a NewHand from the PITsnapshot servlet
    private int numPlayers = 0;
    // halting indicates that the system is being reset, so ignore trades until a new had received
    private boolean halting = false;

    // flag to check if the marker is received before,
    // i.e. flag to check if this player is participating in snapshot already
    private boolean markerReceived = false;
    // an ArrayList to note down players already participating in the snapshot
    private ArrayList<Integer> alreadyParticipatingPlayers = new ArrayList<>();
    // HashSet to store unique cards for counting frequencies later
    HashSet<String> uniqueCards = new HashSet<>();
    // another ArrayList to hold shuffled unique cards
    ArrayList<Object> uniqueCardsShuffled = new ArrayList<>();

    /* The snapshot servlet (PITsnapshot) is expecting to be passed an ObjectMessage
     * where the  object is a HashMap. Therefore this definition of HashMap is
     * provided although it  is not currently used (it is for you to use).
     * PITsnapshot is expecting a set of attribute/value pairs. These include the player
     * number, as in state.put("Player", myPlayerNumber), and each commodity string
     * and the number of that commodity  in the snapshot.
     * Also included below is a utility method  that will convert a HashMap into a string
     * which is useful for printing diagnostic messages to  the console.
     */
    private HashMap<String, Integer> state = new HashMap<>();

    // PITPlayerModel constructor saves what number player this object represents.
    PITPlayerModel(int myNumber) {
        myPlayerNumber = myNumber;
    }

    public void onMessage(Message message) {
        try {
            if (message instanceof ObjectMessage) {
                Object o = ((ObjectMessage) message).getObject();

                /*
                 * There are 6 types of messages:  Reset, NewHand, TenderOffer,
                 * AcceptOffer, RejectOffer, and Marker
                 */

                // Reset the Player.  This message is generated by the PITsnapshot servlet
                if (o instanceof Reset) {
                    doReset((Reset) o);
                    // NewHand received from PITsnapshot
                } else if (o instanceof NewHand) {
                    // Add the new hand into cards
                    doNewHand((NewHand) o);

                    // Receive an offer from another Player
                } else if (o instanceof TenderOffer) {
                    doReceiveTenderOffer((TenderOffer) o);

                    // Another Player accepted our offer
                } else if (o instanceof AcceptOffer) {
                    doReceiveAcceptOffer((AcceptOffer) o);

                    // Another Player rejected our offer
                } else if (o instanceof RejectOffer) {
                    doReceiveRejectOffer((RejectOffer) o);

                } else if (o instanceof Marker) {
                    doMarker((Marker) o);

                } else {
                    System.out.println("PITplayer" + myPlayerNumber + " received unknown Message type");
                    // just ignore it
                }
            }
        } catch (Exception e) {
            System.out.println("Exception thrown in PITplayer" + myPlayerNumber + ": " + e);
        }
    }

    private void doReset(Reset reset) throws Exception {
        // Resetting is done by two messages, first to halt, then to clear
        if (reset.action == Reset.HALT) {
            System.out.println("PITplayer" + myPlayerNumber + " received Reset HALT");
            halting = true;
            // Reply to the PITsnapshot servlet acknowledging the Reset HALT
        } else { // action == Reset.CLEAR
            System.out.println("PITplayer" + myPlayerNumber + " received Reset RESET");
            // Drop all cards in hand
            cards.clear();
            numTrades = 0;
            numPlayers = 0;
            // Reset the marker received flag, participating players' list and state
//            markerReceived = false;
            alreadyParticipatingPlayers.clear();
            state.clear();

            halting = false;
            // Reply to the PITsnapshot servlet acknowledging the Reset
        }
        sendToQueue("PITmonitor", reset);
    }

    private void doNewHand(NewHand hand) throws Exception {
        // Add a new hand of cards.
        // It is actually possible that an offer from another Player has been
        // accepted already, beating the NewHand
        cards.addAll((hand).newHand);
        numPlayers = (hand).numPlayers;
        System.out.println("PITplayer" + myPlayerNumber + " new hand: " + toString(cards));
        // Offer a card to another Player
        doTenderOffer();
    }

    private void doReceiveTenderOffer(TenderOffer trade) throws Exception {
        if (halting) {
            return; // if halting, discard trade
        }

        System.out.println("PITplayer" + myPlayerNumber + " received offer of: " + trade.tradeCard + " from player: " + trade.sourcePlayer);

        // since it is an incoming card, add it to state Map irrespective of this player
        //     accepting or rejecting the offer
        // when this player rejects the offer and sends back the card, it will not be counted twice
        //     because of the arrangement made in doReceiveRejectOffer method which does proper checks
        // add the trade card to state
        addTradeToState(trade.sourcePlayer, trade.tradeCard);

        // When receiving an offer, decide whether to Accept or Reject it

        // if offerred trade card is one of the most frequently occurring cards,
        // accept it; if not, accept it 80% of the times, otherwise it will go into a kind of deadlock
        if (isMostFrequentCard(trade.tradeCard) || Math.random() < 0.4) {

            // Add the Offer to my hand of cards
            cards.add(trade.tradeCard);
            // Pay with one of my cards
            doReplyAccept(trade.sourcePlayer);

        } else {
            /* Otherwise reject the offer and send back the card */
            doReplyReject(trade);
        }
    }

    private void doReplyAccept(int sendTo) throws Exception {

        // if hit maxTrades limit, then stop sending trades
        if (maxTrades(maxTrades)) {
            return;
        }

        // attempt get the least frequent card
        String leastFrequentCard = getLeastFrequentCard();
        // if it is null, that means we have all cards of the same commodity
        //     and hence, do not proceed further
        if (leastFrequentCard == null) return;

        // if the card is not null, go ahead and offer it
        AcceptOffer newTrade = new AcceptOffer();
        // add the least frequent card to it
        newTrade.tradeCard = cards.remove(cards.indexOf(leastFrequentCard)).toString();

        newTrade.sourcePlayer = myPlayerNumber;

        //Send the card to the other player
        System.out.println("PITplayer" + myPlayerNumber + " accepting offer and paying with: " + newTrade.tradeCard + " to player: " + sendTo);
        System.out.println("PITplayer" + myPlayerNumber + " hand: " + toString(cards));
        String sendToJNDI = "PITplayer" + sendTo;
        sendToQueue(sendToJNDI, newTrade);
    }

    // Reply rejecting an offer that was received.  Send back their card.
    private void doReplyReject(TenderOffer trade) throws Exception {
        if (halting) {
            return; // if halting, discard trade
        }

        System.out.println("PITplayer" + myPlayerNumber + " rejecting offer of: " + trade.tradeCard + " from player: " + trade.sourcePlayer);
        System.out.println("PITplayer" + myPlayerNumber + " hand: " + toString(cards));

        // if hit maxTrades limit, then stop sending trades
        if (maxTrades(maxTrades)) {
            return;
        }

        // Send back their card that I am rejecting
        RejectOffer newTrade = new RejectOffer();
        newTrade.tradeCard = trade.tradeCard;
        newTrade.sourcePlayer = myPlayerNumber;

        //Send the card to the other player
        String sendToJNDI = "PITplayer" + trade.sourcePlayer;
        sendToQueue(sendToJNDI, newTrade);

    }

    // Handle receiving a message that a previous offer has been accepted.
    // They would have replied with another card as payment.
    private void doReceiveAcceptOffer(AcceptOffer trade) throws Exception {
        if (halting) {
            return; // if halting, discard trade
        }
        // Having received a AcceptOffer from another Player, add it to my hand of cards
        cards.add(trade.tradeCard);
        // add the received trade card to state
        addTradeToState(trade.sourcePlayer, trade.tradeCard);

        System.out.println("PITplayer" + myPlayerNumber + " received: " + trade.tradeCard + " as payment from player: " + trade.sourcePlayer);
        System.out.println("PITplayer" + myPlayerNumber + " hand: " + toString(cards));
        // Make another offer to a random player
        doTenderOffer();
    }

    // Handle receiving a reject message regarding a prior offer I made
    private void doReceiveRejectOffer(RejectOffer trade) throws Exception {
        if (halting) {
            return; // if halting, discard trade
        }
        // Because the offer was rejected, and returned, add it back into my cards
        cards.add(trade.tradeCard);
        // add the rejected trade card to state
        addTradeToState(trade.sourcePlayer, trade.tradeCard);
        // this is important so that we do not miss out if marker was received later
        // if the card has already been counted, it won't be re-counted, because the
        // rejecting player will already be there in the alreadyParticipatingPlayers list


        System.out.println("PITplayer" + myPlayerNumber + " received rejected offer of: " + trade.tradeCard + " from player: " + trade.sourcePlayer);
        System.out.println("PITplayer" + myPlayerNumber + " hand: " + toString(cards));
        // Make another offer to a random player
        doTenderOffer();
    }

    // Make an offer to a random player
    private void doTenderOffer() throws Exception {

        // if hit maxTrades limit, then stop sending trades
        if (maxTrades(maxTrades)) {
            return;
        }

        /*
         * If numPlayers == 0, while we have received a TenderOffer, we have not
         * received our NewHand yet, so we don't know how many players there
         * are.  Therefore, don't send out a TenderOffer at this time.
         *
         */
        if (numPlayers == 0) {
            return;
        }

        // attempt get the least frequent card
        String leastFrequentCard = getLeastFrequentCard();
        // if it is null, that means we already have all cards of the same commodity
        //     and hence, do not proceed further
        if (leastFrequentCard == null) return;

        // if the card is not null, go ahead and offer it
        TenderOffer newTrade = new TenderOffer();
        // add the least frequent card to the offer
        newTrade.tradeCard = cards.remove(cards.indexOf(leastFrequentCard)).toString();

        newTrade.sourcePlayer = myPlayerNumber;

        // Find a random player to trade to (not including myself)
        int sendTo = myPlayerNumber;
        while (sendTo == myPlayerNumber) {
            sendTo = Math.round((float) Math.random() * (numPlayers - 1));
        }

        //Send the card to the other player
        System.out.println("PITplayer" + myPlayerNumber + " offered: " + newTrade.tradeCard + " to player: " + sendTo);
        String sendToJNDI = "PITplayer" + sendTo;
        sendToQueue(sendToJNDI, newTrade);
    }

    /**
     * This method accepts marker object and implements all the steps of Chandy Lamport algo.
     * It first counts this player's own state, sends markers to all outgoing channels, who
     * are not participating in the snapshot, and tracks all the incoming trades which are from
     * players who are not participating in the snapshot
     *
     * @param marker a Marker object containing id of the sender
     * @throws Exception sendToQueue method called in this method may throw Exception
     */
    private void doMarker(Marker marker) throws Exception {
        // if this player is not yet participating in snapshot, create a fresh snapshot of the state
        if (!markerReceived) {
            // set marker received flag to true so that snapshotting starts
            markerReceived = true;

            // traverse all cards...
            for (Object c : cards) {
                // ...and add them to state HashMap with their counts
                addCardToState(c.toString());
            }

            // create a new Marker object with this player as source
            Marker m = new Marker(myPlayerNumber);
            // place marker on all outgoing channels (except the current player)
            for (int player = 0; player < numPlayers; player++) {
                // don't add current player to alreadyParticipatingPlayers list
                if (player == myPlayerNumber) continue;
                // send marker to the player
                String sendToJNDI = "PITplayer" + player;
                sendToQueue(sendToJNDI, m);
                // display message on console
                System.out.println("PITplayer" + myPlayerNumber + " sent: Marker to player:" + player);
            }
        }

        // check if the marker came from PITsnapshot and source player is not already in the list
        if (marker.source != -1 && !alreadyParticipatingPlayers.contains(marker.source)) {
            // if not, add source to alreadyParticipatingPlayers list
            alreadyParticipatingPlayers.add(marker.source);
        }

        // check if stopping condition is met
        // i.e. all players participated in snapshot
        if (alreadyParticipatingPlayers.size() >= (numPlayers - 1)) {
            // add to the state Map the identifier of who the snapshot is coming from
            state.put("Player", myPlayerNumber);
            // send final snapshot to PITsnapshot
            sendToQueue("PITsnapshot", state);

            // display message on console
            System.out.println("PITplayer" + myPlayerNumber + ": Final snapshot: " + toString(state));

            // clear our trackers
            markerReceived = false;
            alreadyParticipatingPlayers.clear();
            // clear state
            state.clear();
        }
    }

    // Create a string of hand size and all cards
    private String toString(ArrayList hand) {

        String cardsString = "size: " + hand.size() + " ";
        for (int i = 0; i < hand.size(); i++) {
            cardsString += hand.get(i) + " ";
        }
        return cardsString;
    }

    // Create a printable version of the state
    private String toString(HashMap<String, Integer> state) {
        String stateString = "";
        for (Iterator it = state.entrySet().iterator(); it.hasNext(); ) {
            Map.Entry entry = (Map.Entry) it.next();
            String commodity = (String) entry.getKey();
            int number = ((Integer) entry.getValue()).intValue();
            stateString += "{" + commodity + ":" + number + "} ";
        }
        return stateString;
    }

    // Send an object to a Queue, given its JNDI name
    private void sendToQueue(String queueJNDI, Serializable message) throws Exception {
        // Gather necessary JMS resources
        Context ctxt = new InitialContext();
        Connection con = ((ConnectionFactory) ctxt.lookup("openejb:Resource/myConnectionFactory")).createConnection();
        Session session = con.createSession(false, Session.AUTO_ACKNOWLEDGE);
        Queue q = (Queue) ctxt.lookup("openejb:Resource/" + queueJNDI);
        MessageProducer writer = session.createProducer(q);
        ObjectMessage msg = session.createObjectMessage(message);
        // Send the object to the Queue
        writer.send(msg);
        session.close();
        con.close();
        ctxt.close();
    }

    // Stop trading when the max number of Trades is reached
    private boolean maxTrades(int max) {
        if ((numTrades % 100) == 0) {
            System.out.println("PITplayer" + myPlayerNumber + " numTrades: " + numTrades);
        }
        return (numTrades++ < max) ? false : true;
    }

    /**
     * This method adds a trade to the state.
     * It first verifies if this player is participating in the snapshot, and also
     * if the source player is not already participating in the snapshot before adding the trade
     *
     * @param sourcePlayer integer id of the player from whom we received the trade
     * @param tradeCard    card/commodity to be added to state
     */
    private void addTradeToState(int sourcePlayer, String tradeCard) {
        // very first, check if the current player is participating in the snapshot
        // and then, check if the trade came from a player whose incoming channel we are not tracking
        // if any of the conditions occur, do not proceed
        if (!markerReceived || alreadyParticipatingPlayers.contains(sourcePlayer)) return;

        // add card to the state Map
        addCardToState(tradeCard);
    }

    /**
     * This method adds a String card to the state Map if not already present
     * if already present, it increments its count
     *
     * @param tradeCard trade card to be added to the state Map
     */
    private void addCardToState(String tradeCard) {
        // store the commodity/tradeCard in the state Map
        // and if already present, increment its count
        if (state.containsKey(tradeCard)) {
            // card present, increment count
            state.put(tradeCard, state.get(tradeCard) + 1);
        } else {
            // new card for the state Map, add it with count 1
            state.put(tradeCard, 1);
        }
    }

    /**
     * This method takes in a card and checks if it is (one of the) most frequently
     * occurring cards in our cards list
     *
     * @param tradeCard String card to check if it is most frequently occurring card
     * @return true if it is most frequently occurring card, false otherwise
     */
    private boolean isMostFrequentCard(String tradeCard) {
        // create uniqueCards list
        uniqueCards.clear();
        // add all cards to it (duplicates will be removed)
        uniqueCards.addAll(cards);
        // frequency counter
        int maxFreq = 0;
        // traverse each unique card and determine the maximum frequency number
        for (Object c : uniqueCards) {
            // find frequency of the card
            int freq = Collections.frequency(cards, c);
            // if the new frequency is greater than before,
            if (freq > maxFreq) {
                // change the maxFreq count keeper
                maxFreq = freq;
            }
        }
        // now, check if passed tradeCard has that frequency and return the result
        return Collections.frequency(cards, tradeCard) == maxFreq;
    }

    /**
     * This method gives out the leaast frequent card from the cards list
     *
     * @return least frequently occurring card; null if monopoly already achieved
     */
    private String getLeastFrequentCard() {
        // create uniqueCards list
        uniqueCards.clear();
        // add all cards to it (duplicates will be removed)
        uniqueCards.addAll(cards);
        // empty the shuffled uniqye cards list
        uniqueCardsShuffled.clear();
        // add all unique cards to the ArrayList, so that we can shuffle them
        uniqueCardsShuffled.addAll(uniqueCards);
        // shuffle them finally
        Collections.shuffle(uniqueCardsShuffled);

        // maximum possible frequency is cards.size(),
        //     any card which is least frequent has to have a frequency less than this
        //     hence, we choose this as the initial minFreq
        // when monopoly is achieved, the minimum frequency would be cards.size
        //     in that case, a card is not returned, instead, a null is returned automatically
        int minFreq = cards.size();
        // card keeper
        String leastFrequentCard = null;

        // traverse each unique card and determine the least frequent card
        for (Object c : uniqueCardsShuffled) {
            // find frequency of the card
            int freq = Collections.frequency(cards, c);
            // if the new frequency is less than before,
            if (freq < minFreq) { // this condition is never met in monopoly, making leastFrequentCard to stay null
                // change the minFreq count keeper
                minFreq = freq;
                // also change the least frequent card
                leastFrequentCard = c.toString();
            }
        }

        // return the least occurring card
        // it automatically stays null if monopoly is achieved already
        // this indicates that the player doesn't need to play any further
        return leastFrequentCard;
    }
}
